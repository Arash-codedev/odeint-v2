<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Adapt your own state types</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;boost.sandbox.numeric.odeint">
<link rel="up" href="../extend_odeint.html" title="Extend odeint">
<link rel="prev" href="../extend_odeint.html" title="Extend odeint">
<link rel="next" href="write_own_steppers.html" title="Write own steppers">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../extend_odeint.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../extend_odeint.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="write_own_steppers.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types"></a><a class="link" href="adapt_your_own_state_types.html" title="Adapt your own state types">Adapt
      your own state types</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.construction_resizing">Construction/Resizing</a></span></dt>
<dt><span class="section"><a href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.algebraic_operations">Algebraic
        operations</a></span></dt>
</dl></div>
<p>
        One of the main goals of odeint is to provide algorithms independent from
        the underlying state type. The state type is a type representing the state
        of the ODE, that is the variable x. As we usually deal with systems of ODEs,
        the state type is represented by some sort of container. Most often, the
        value type of the container is simply <code class="computeroutput"><span class="keyword">double</span></code>,
        as usually ODEs are defined as systems of real variables. However, it is
        also possible to use complex types (<code class="computeroutput"><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span></code>) as underlying value type. Moreover,
        you can even adopt odeint to work with <span class="underline">any</span>
        value type as long as the required operations are defined. However, in the
        following I will describe how your own state types can be used to run with
        odeint. I will assume that the state type is some sort of container aggregating
        a number of values representing state of the ODE. As odeint also takes care
        for the memory management of where intermediate results are stored, it first
        of all needs to know how to construct/destruct and possibly resize the state
        type. Additionally, it requires to be told how basic algebraic operations
        are to be performed on state types. So when introducing new state types to
        odeint, the following points have to be considered:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            construction/destruction
          </li>
<li class="listitem">
            resizing (if possible/required)
          </li>
<li class="listitem">
            algebraic operations
          </li>
</ul></div>
<p>
        Of course, odeint already provides basic interfaces for most of the usual
        state types. So if you use a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>,
        or a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">array</span></code> as state type no additional work
        is required, they just work out of the box.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.construction_resizing"></a><a class="link" href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.construction_resizing" title="Construction/Resizing">Construction/Resizing</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.construction_resizing.vectors_derived_from__std__vector_">Vectors
          derived from <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code></a></span></dt>
<dt><span class="section"><a href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.construction_resizing.std__list">std::list</a></span></dt>
</dl></div>
<p>
          We distinguish between two basic state types: fixed sized and dynamically
          sized. For fixed size state types the default constructor <code class="computeroutput"><span class="identifier">state_type</span><span class="special">()</span></code>
          already allocates the required memory, prominent example is <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span><span class="identifier">N</span><span class="special">&gt;</span></code>. Dynamically sized types have to be
          resized to make sure enough memory is allocated, the standard constructor
          does not take care of the resizing. Examples for this are the STL containers
          like <code class="computeroutput"><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span></code>.
        </p>
<p>
          The most easy way of getting your own state type to work with odeint is
          to use a fixed size state, base calculations on the range_algebra and provide
          the following functionality:
        </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  <p>
                    Name
                  </p>
                </th>
<th>
                  <p>
                    Expression
                  </p>
                </th>
<th>
                  <p>
                    Type
                  </p>
                </th>
<th>
                  <p>
                    Semantics
                  </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                  <p>
                    Construct State
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">State</span> <span class="identifier">x</span><span class="special">()</span></code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="keyword">void</span></code>
                  </p>
                </td>
<td>
                  <p>
                    Creates an instance of <code class="computeroutput"><span class="identifier">State</span></code>
                    and allocates memory.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    Begin of the sequence
                  </p>
                </td>
<td>
                  <p>
                    boost::begin(x)
                  </p>
                </td>
<td>
                  <p>
                    Iterator
                  </p>
                </td>
<td>
                  <p>
                    Returns an iterator pointing to the begin of the sequence
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    End of the sequence
                  </p>
                </td>
<td>
                  <p>
                    boost::end(x)
                  </p>
                </td>
<td>
                  <p>
                    Iterator
                  </p>
                </td>
<td>
                  <p>
                    Returns an iterator pointing to the end of the sequence
                  </p>
                </td>
</tr>
</tbody>
</table></div>
<div class="caution"><table border="0" summary="Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../../images/caution.png"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>
            If your state type does not allocate memory by default construction,
            you <span class="bold"><strong>must define it as resizeable</strong></span> and
            provide resize functionality (see below). Otherwise segmentation faults
            will occur.
          </p></td></tr>
</table></div>
<p>
          So fixed sized arrays supported by <a href="http://www.boost.org/doc/libs/release/libs/range/index.html" target="_top">Boost.Range</a>
          immediately work with odeint. For dynamically sized arrays one has to additionally
          supply the resize functionality. First, the state has to be tagged as resizeable
          by specializing the struct <code class="computeroutput"><span class="identifier">is_resizeable</span></code>
          which consists of one typedef and one bool value:
        </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  <p>
                    Name
                  </p>
                </th>
<th>
                  <p>
                    Expression
                  </p>
                </th>
<th>
                  <p>
                    Type
                  </p>
                </th>
<th>
                  <p>
                    Semantics
                  </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                  <p>
                    Resizability
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">is_resizeable</span><span class="special">&lt;</span><span class="identifier">State</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">true_type</span></code> or <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">false_type</span></code>
                  </p>
                </td>
<td>
                  <p>
                    Determines resizeability of the state type, returns <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">true_type</span></code> if the state is resizeable.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    Resizability
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">is_resizeable</span><span class="special">&lt;</span><span class="identifier">State</span><span class="special">&gt;::</span><span class="identifier">value</span></code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="keyword">bool</span></code>
                  </p>
                </td>
<td>
                  <p>
                    Same as above, but with <code class="computeroutput"><span class="keyword">bool</span></code>
                    value.
                  </p>
                </td>
</tr>
</tbody>
</table></div>
<p>
          Defining <code class="computeroutput"><span class="identifier">type</span></code> to be <code class="computeroutput"><span class="identifier">true_type</span></code> and <code class="computeroutput"><span class="identifier">value</span></code>
          as <code class="computeroutput"><span class="keyword">true</span></code> tells odeint that
          your state is resizeable. By default, odeint now expects the support of
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">size</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span></code> and
          a <code class="computeroutput"><span class="identifier">x</span><span class="special">.</span><span class="identifier">resize</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">size</span><span class="special">(</span><span class="identifier">y</span><span class="special">)</span> <span class="special">)</span></code>
          member function for resizing:
        </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  <p>
                    Name
                  </p>
                </th>
<th>
                  <p>
                    Expression
                  </p>
                </th>
<th>
                  <p>
                    Type
                  </p>
                </th>
<th>
                  <p>
                    Semantics
                  </p>
                </th>
</tr></thead>
<tbody>
<tr>
<td>
                  <p>
                    Get size
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">size</span><span class="special">(</span>
                    <span class="identifier">x</span> <span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">size_type</span></code>
                  </p>
                </td>
<td>
                  <p>
                    Returns the current size of x.
                  </p>
                </td>
</tr>
<tr>
<td>
                  <p>
                    Resize
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="identifier">x</span><span class="special">.</span><span class="identifier">resize</span><span class="special">(</span>
                    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">size</span><span class="special">(</span>
                    <span class="identifier">y</span> <span class="special">)</span>
                    <span class="special">)</span></code>
                  </p>
                </td>
<td>
                  <p>
                    <code class="computeroutput"><span class="keyword">void</span></code>
                  </p>
                </td>
<td>
                  <p>
                    Resizes x to have the same size as y.
                  </p>
                </td>
</tr>
</tbody>
</table></div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.construction_resizing.vectors_derived_from__std__vector_"></a><a class="link" href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.construction_resizing.vectors_derived_from__std__vector_" title="Vectors derived from std::vector">Vectors
          derived from <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code></a>
</h5></div></div></div>
<p>
            As a first example we take the most simple case and implement our own
            vector <code class="computeroutput"><span class="identifier">my_vector</span></code> which
            will be derived from <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>.
            Using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code> as base class ensures that resizing
            and iteration via <a href="http://www.boost.org/doc/libs/release/libs/range/index.html" target="_top">Boost.Range</a>
            work out-of-box. The only thing that has to be done is declaring my_vector
            as resizeable as it is a dynamically sized array:
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">my_vector</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">double</span> <span class="special">&gt;</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">my_vector</span><span class="special">(</span> <span class="keyword">const</span> <span class="identifier">size_t</span> <span class="identifier">N</span> <span class="special">)</span>
        <span class="special">:</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">double</span> <span class="special">&gt;(</span> <span class="identifier">N</span> <span class="special">)</span>
    <span class="special">{</span> <span class="special">}</span>

    <span class="identifier">my_vector</span><span class="special">()</span>
        <span class="special">:</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">double</span> <span class="special">&gt;()</span>
    <span class="special">{</span> <span class="special">}</span>

<span class="comment">// ...</span>
<span class="special">};</span>

<span class="comment">// define my_vector as reizeable</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">numeric</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">odeint</span> <span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_resizeable</span><span class="special">&lt;</span> <span class="identifier">my_vector</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">true_type</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">bool</span> <span class="identifier">value</span> <span class="special">=</span> <span class="identifier">type</span><span class="special">::</span><span class="identifier">value</span><span class="special">;</span>
<span class="special">};</span>

<span class="special">}</span> <span class="special">}</span> <span class="special">}</span>
</pre>
<p>
          </p>
<p>
            If we wouldn't specialize the <code class="computeroutput"><span class="identifier">is_resizeable</span></code>
            template, the code would still compile but odeint would not adjust the
            size of temporary internal instances of my_vector and hence try to fill
            zero-sized vectors resulting in segmentation faults! The full example
            can be found in <a href="https://github.com/headmyshoulder/odeint-v2/tree/master/libs/numeric/odeint/examples/my_vector.cpp" target="_top">my_vector.cpp</a>
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.construction_resizing.std__list"></a><a class="link" href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.construction_resizing.std__list" title="std::list">std::list</a>
</h5></div></div></div>
<p>
            If your state type does work with <a href="http://www.boost.org/doc/libs/release/libs/range/index.html" target="_top">Boost.Range</a>,
            but handles resizing differently you are required to specialize two implementations
            used by odeint to check a state's size and to resize:
          </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      Name
                    </p>
                  </th>
<th>
                    <p>
                      Expression
                    </p>
                  </th>
<th>
                    <p>
                      Type
                    </p>
                  </th>
<th>
                    <p>
                      Semantics
                    </p>
                  </th>
</tr></thead>
<tbody>
<tr>
<td>
                    <p>
                      Check size
                    </p>
                  </td>
<td>
                    <p>
                      <code class="computeroutput"><span class="identifier">same_size_impl</span><span class="special">&lt;</span><span class="identifier">State</span><span class="special">,</span><span class="identifier">State</span><span class="special">&gt;::</span><span class="identifier">same_size</span><span class="special">(</span><span class="identifier">x</span>
                      <span class="special">,</span> <span class="identifier">y</span><span class="special">)</span></code>
                    </p>
                  </td>
<td>
                    <p>
                      <code class="computeroutput"><span class="keyword">bool</span></code>
                    </p>
                  </td>
<td>
                    <p>
                      Returns true if the size of x equals the size of y.
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      Resize
                    </p>
                  </td>
<td>
                    <p>
                      <code class="computeroutput"><span class="identifier">resize_impl</span><span class="special">&lt;</span><span class="identifier">State</span><span class="special">,</span><span class="identifier">State</span><span class="special">&gt;::</span><span class="identifier">resize</span><span class="special">(</span><span class="identifier">x</span>
                      <span class="special">,</span> <span class="identifier">y</span><span class="special">)</span></code>
                    </p>
                  </td>
<td>
                    <p>
                      <code class="computeroutput"><span class="keyword">void</span></code>
                    </p>
                  </td>
<td>
                    <p>
                      Resizes x to have the same size as y.
                    </p>
                  </td>
</tr>
</tbody>
</table></div>
<p>
            As an example we will use a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span></code>
            as state type in odeint. Because <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span></code>
            is not supported by <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">size</span></code>
            we have to replace the same_size and resize implementation to get list
            to work with odeint. The following code shows the required template specializations:
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span> <span class="keyword">double</span> <span class="special">&gt;</span> <span class="identifier">state_type</span><span class="special">;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">numeric</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">odeint</span> <span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_resizeable</span><span class="special">&lt;</span> <span class="identifier">state_type</span> <span class="special">&gt;</span>
<span class="special">{</span> <span class="comment">// declare resizeablility</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">true_type</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">value</span> <span class="special">=</span> <span class="identifier">type</span><span class="special">::</span><span class="identifier">value</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="special">&gt;</span> 
<span class="keyword">struct</span> <span class="identifier">same_size_impl</span><span class="special">&lt;</span> <span class="identifier">state_type</span> <span class="special">,</span> <span class="identifier">state_type</span> <span class="special">&gt;</span>
<span class="special">{</span> <span class="comment">// define how to check size</span>
    <span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">same_size</span><span class="special">(</span> <span class="keyword">const</span> <span class="identifier">state_type</span> <span class="special">&amp;</span><span class="identifier">v1</span> <span class="special">,</span>
                           <span class="keyword">const</span> <span class="identifier">state_type</span> <span class="special">&amp;</span><span class="identifier">v2</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">v1</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">v2</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">resize_impl</span><span class="special">&lt;</span> <span class="identifier">state_type</span> <span class="special">,</span> <span class="identifier">state_type</span> <span class="special">&gt;</span>
<span class="special">{</span> <span class="comment">// define how to resize</span>
    <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">resize</span><span class="special">(</span> <span class="identifier">state_type</span> <span class="special">&amp;</span><span class="identifier">v1</span> <span class="special">,</span>
                        <span class="keyword">const</span> <span class="identifier">state_type</span> <span class="special">&amp;</span><span class="identifier">v2</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">v1</span><span class="special">.</span><span class="identifier">resize</span><span class="special">(</span> <span class="identifier">v2</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="special">}</span> <span class="special">}</span> <span class="special">}</span> 
</pre>
<p>
          </p>
<p>
            With these definitions odeint knows how to resize <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span></code>s
            and so they can be used as state types. A complete example can be found
            in <a href="https://github.com/headmyshoulder/odeint-v2/tree/master/libs/numeric/odeint/examples/list_lattice.cpp" target="_top">list_lattice.cpp</a>.
          </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.algebraic_operations"></a><a class="link" href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.algebraic_operations" title="Algebraic operations">Algebraic
        operations</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.algebraic_operations.gsl_vector">GSL
          Vector</a></span></dt>
<dt><span class="section"><a href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.algebraic_operations.vector_space_algebra">Vector
          Space Algebra</a></span></dt>
<dt><span class="section"><a href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.algebraic_operations.boost_ublas">Boost.Ublas</a></span></dt>
<dt><span class="section"><a href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.algebraic_operations.point_type">Point
          type</a></span></dt>
</dl></div>
<p>
          If your state type is not supported by Boost.Range there are several possibilities
          to tell odeint how to do algebraic operations:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              Implement <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">begin</span></code> and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">end</span></code>
              for your state type so it works with Boost.Range.
            </li>
<li class="listitem">
              Implement vector-vector addition operator <code class="computeroutput"><span class="special">+</span></code>
              and scalar-vector multiplication operator <code class="computeroutput"><span class="special">*</span></code>
              and use the non-standard <code class="computeroutput"><span class="identifier">vector_space_algebra</span></code>.
            </li>
<li class="listitem">
              Implement your own algebra that defines the required operations.
            </li>
</ul></div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.algebraic_operations.gsl_vector"></a><a class="link" href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.algebraic_operations.gsl_vector" title="GSL Vector">GSL
          Vector</a>
</h5></div></div></div>
<p>
            All the above examples use <a href="http://www.boost.org/doc/libs/release/libs/range/index.html" target="_top">Boost.Range</a>
            to iterate through the elements of the state type and perform the algebraic
            operation for each element. This is the most natural way when dealing
            with state types which are some kind of container. But what to do if
            your state type does not support iterators at all? In the following example
            we will try to use the <code class="computeroutput"><span class="identifier">gsl_vector</span></code>
            type from <a href="http://www.gsl.org" target="_top">GSL</a> (GNU Scientific
            Library) as state type in odeint. The GSL is a C library, so <code class="computeroutput"><span class="identifier">gsl_vector</span></code> has neither constructor,
            nor destructor or any <code class="computeroutput"><span class="identifier">begin</span></code>
            or <code class="computeroutput"><span class="identifier">end</span></code> function, no iterators
            at all. So to make it work with odeint plenty of things have to be implemented.
            Note that all of the work shown here is already included in odeint, so
            using gls_vectors in odeint doesn't require any further adjustments.
            We start with defining appropriate constructors and destructors. This
            is done by specializing the <code class="computeroutput"><span class="identifier">state_wrapper</span></code>
            for <code class="computeroutput"><span class="identifier">gsl_vector</span></code>. State
            wrappers are used by the steppers internally to create and manage temporary
            instances of state types:
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">state_wrapper</span><span class="special">&lt;</span> <span class="identifier">gsl_vector</span><span class="special">*</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">value_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">gsl_vector</span><span class="special">*</span> <span class="identifier">state_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">state_wrapper</span><span class="special">&lt;</span> <span class="identifier">gsl_vector</span><span class="special">*</span> <span class="special">&gt;</span> <span class="identifier">state_wrapper_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">true_type</span> <span class="identifier">is_resizeable</span><span class="special">;</span>

    <span class="identifier">state_type</span> <span class="identifier">m_v</span><span class="special">;</span>

    <span class="identifier">state_wrapper</span><span class="special">(</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">m_v</span> <span class="special">=</span> <span class="identifier">gsl_vector_alloc</span><span class="special">(</span> <span class="number">1</span> <span class="special">);</span>
    <span class="special">}</span>

    <span class="identifier">state_wrapper</span><span class="special">(</span> <span class="keyword">const</span> <span class="identifier">state_wrapper_type</span> <span class="special">&amp;</span><span class="identifier">x</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">resize</span><span class="special">(</span> <span class="identifier">m_v</span> <span class="special">,</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">m_v</span> <span class="special">);</span>
        <span class="identifier">gsl_vector_memcpy</span><span class="special">(</span> <span class="identifier">m_v</span> <span class="special">,</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">m_v</span> <span class="special">);</span>
    <span class="special">}</span>


    <span class="special">~</span><span class="identifier">state_wrapper</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="identifier">gsl_vector_free</span><span class="special">(</span> <span class="identifier">m_v</span> <span class="special">);</span>
    <span class="special">}</span>

<span class="special">};</span>
</pre>
<p>
          </p>
<p>
            This <code class="computeroutput"><span class="identifier">state_wrapper</span></code> specialization
            tells odeint how gsl_vectors are created, copied and destroyed. Next
            we need resizing, this is required because gsl_vectors are dynamically
            sized objects: 
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_resizeable</span><span class="special">&lt;</span> <span class="identifier">gsl_vector</span><span class="special">*</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">true_type</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">value</span> <span class="special">=</span> <span class="identifier">type</span><span class="special">::</span><span class="identifier">value</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">same_size_impl</span><span class="special">&lt;</span> <span class="identifier">gsl_vector</span><span class="special">*</span> <span class="special">,</span> <span class="identifier">gsl_vector</span><span class="special">*</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">same_size</span><span class="special">(</span> <span class="keyword">const</span> <span class="identifier">gsl_vector</span><span class="special">*</span> <span class="identifier">x</span> <span class="special">,</span> <span class="keyword">const</span> <span class="identifier">gsl_vector</span><span class="special">*</span> <span class="identifier">y</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">x</span><span class="special">-&gt;</span><span class="identifier">size</span> <span class="special">==</span> <span class="identifier">y</span><span class="special">-&gt;</span><span class="identifier">size</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">resize_impl</span><span class="special">&lt;</span> <span class="identifier">gsl_vector</span><span class="special">*</span> <span class="special">,</span> <span class="identifier">gsl_vector</span><span class="special">*</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">resize</span><span class="special">(</span> <span class="identifier">gsl_vector</span><span class="special">*</span> <span class="identifier">x</span> <span class="special">,</span> <span class="keyword">const</span> <span class="identifier">gsl_vector</span><span class="special">*</span> <span class="identifier">y</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">gsl_vector_free</span><span class="special">(</span> <span class="identifier">x</span> <span class="special">);</span>
        <span class="identifier">x</span> <span class="special">=</span> <span class="identifier">gsl_vector_alloc</span><span class="special">(</span> <span class="identifier">y</span><span class="special">-&gt;</span><span class="identifier">size</span> <span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
            Up to now, we defined creation and resizing, but gsl_vectors also don't
            support iterators, so we first implement a gsl iterator:
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="comment">/*
 * defines an iterator for gsl_vector
 */</span>
<span class="keyword">class</span> <span class="identifier">gsl_vector_iterator</span> 
      <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">iterator_facade</span><span class="special">&lt;</span> <span class="identifier">gsl_vector_iterator</span> <span class="special">,</span> <span class="keyword">double</span> <span class="special">,</span> 
                                       <span class="identifier">boost</span><span class="special">::</span><span class="identifier">random_access_traversal_tag</span> <span class="special">&gt;</span>
<span class="special">{</span>
<span class="keyword">public</span> <span class="special">:</span>

    <span class="identifier">gsl_vector_iterator</span><span class="special">(</span> <span class="keyword">void</span> <span class="special">):</span> <span class="identifier">m_p</span><span class="special">(</span><span class="number">0</span><span class="special">)</span> <span class="special">,</span> <span class="identifier">m_stride</span><span class="special">(</span> <span class="number">0</span> <span class="special">)</span> <span class="special">{</span> <span class="special">}</span>
    <span class="keyword">explicit</span> <span class="identifier">gsl_vector_iterator</span><span class="special">(</span> <span class="identifier">gsl_vector</span> <span class="special">*</span><span class="identifier">p</span> <span class="special">)</span> <span class="special">:</span> <span class="identifier">m_p</span><span class="special">(</span> <span class="identifier">p</span><span class="special">-&gt;</span><span class="identifier">data</span> <span class="special">)</span> <span class="special">,</span> <span class="identifier">m_stride</span><span class="special">(</span> <span class="identifier">p</span><span class="special">-&gt;</span><span class="identifier">stride</span> <span class="special">)</span> <span class="special">{</span> <span class="special">}</span>
    <span class="keyword">friend</span> <span class="identifier">gsl_vector_iterator</span> <span class="identifier">end_iterator</span><span class="special">(</span> <span class="identifier">gsl_vector</span> <span class="special">*</span> <span class="special">);</span>

<span class="keyword">private</span> <span class="special">:</span>

    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">iterator_core_access</span><span class="special">;</span>
    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="identifier">const_gsl_vector_iterator</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">increment</span><span class="special">(</span> <span class="keyword">void</span> <span class="special">)</span> <span class="special">{</span> <span class="identifier">m_p</span> <span class="special">+=</span> <span class="identifier">m_stride</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">decrement</span><span class="special">(</span> <span class="keyword">void</span> <span class="special">)</span> <span class="special">{</span> <span class="identifier">m_p</span> <span class="special">-=</span> <span class="identifier">m_stride</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">advance</span><span class="special">(</span> <span class="identifier">ptrdiff_t</span> <span class="identifier">n</span> <span class="special">)</span> <span class="special">{</span> <span class="identifier">m_p</span> <span class="special">+=</span> <span class="identifier">n</span><span class="special">*</span><span class="identifier">m_stride</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">equal</span><span class="special">(</span> <span class="keyword">const</span> <span class="identifier">gsl_vector_iterator</span> <span class="special">&amp;</span><span class="identifier">other</span> <span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">m_p</span> <span class="special">==</span> <span class="identifier">other</span><span class="special">.</span><span class="identifier">m_p</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">equal</span><span class="special">(</span> <span class="keyword">const</span> <span class="identifier">const_gsl_vector_iterator</span> <span class="special">&amp;</span><span class="identifier">other</span> <span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">double</span><span class="special">&amp;</span> <span class="identifier">dereference</span><span class="special">(</span> <span class="keyword">void</span> <span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="special">*</span><span class="identifier">m_p</span><span class="special">;</span> <span class="special">}</span>

    <span class="keyword">double</span> <span class="special">*</span><span class="identifier">m_p</span><span class="special">;</span>
    <span class="identifier">size_t</span> <span class="identifier">m_stride</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            A similar class exists for the <code class="computeroutput"><span class="keyword">const</span></code>
            version of the iterator. Then we have a function returning the end iterator
            (similarily for <code class="computeroutput"><span class="keyword">const</span></code> again):
            
</p>
<pre class="programlisting"><span class="identifier">gsl_vector_iterator</span> <span class="identifier">end_iterator</span><span class="special">(</span> <span class="identifier">gsl_vector</span> <span class="special">*</span><span class="identifier">x</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">gsl_vector_iterator</span> <span class="identifier">iter</span><span class="special">(</span> <span class="identifier">x</span> <span class="special">);</span>
    <span class="identifier">iter</span><span class="special">.</span><span class="identifier">m_p</span> <span class="special">+=</span> <span class="identifier">iter</span><span class="special">.</span><span class="identifier">m_stride</span> <span class="special">*</span> <span class="identifier">x</span><span class="special">-&gt;</span><span class="identifier">size</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">iter</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
            Finally, the bindings for <a href="http://www.boost.org/doc/libs/release/libs/range/index.html" target="_top">Boost.Range</a>
            are added: 
</p>
<pre class="programlisting"><span class="comment">// template&lt;&gt;</span>
<span class="keyword">inline</span> <span class="identifier">gsl_vector_iterator</span> <span class="identifier">range_begin</span><span class="special">(</span> <span class="identifier">gsl_vector</span> <span class="special">*</span><span class="identifier">x</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">gsl_vector_iterator</span><span class="special">(</span> <span class="identifier">x</span> <span class="special">);</span>
<span class="special">}</span>

<span class="comment">// template&lt;&gt;</span>
<span class="keyword">inline</span> <span class="identifier">gsl_vector_iterator</span> <span class="identifier">range_end</span><span class="special">(</span> <span class="identifier">gsl_vector</span> <span class="special">*</span><span class="identifier">x</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">end_iterator</span><span class="special">(</span> <span class="identifier">x</span> <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            Again with similar definitions for the <code class="computeroutput"><span class="keyword">const</span></code>
            versions. This eventually makes odeint work with gsl vectors as state
            types. The full code for these bindings is found in <a href="https://github.com/headmyshoulder/odeint-v2/tree/master/boost/numeric/odeint/external/gsl/gsl_wrapper.hpp" target="_top">gsl_wrapper.hpp</a>.
            It might look rather complicated but keep in mind that gsl is a pre compiled
            C library so it is quite an achievement that it's possible to get it
            working at all in the first place.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.algebraic_operations.vector_space_algebra"></a><a class="link" href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.algebraic_operations.vector_space_algebra" title="Vector Space Algebra">Vector
          Space Algebra</a>
</h5></div></div></div>
<p>
            As seen above, the standard way of performing algebraic operations on
            container-like state types in odeint is to iterate through the elements
            of the container and perform the operations element-wise on the underlying
            value type. This is realized by means of the <code class="computeroutput"><span class="identifier">range_algebra</span></code>
            that uses <a href="http://www.boost.org/doc/libs/release/libs/range/index.html" target="_top">Boost.Range</a>
            for obtaining iterators of the state types. However, there are other
            ways to implement the algebraic operations on containers, one of which
            is defining the addition/multiplication operators for the containers
            directly and then using the <code class="computeroutput"><span class="identifier">vector_space_algebra</span></code>.
            If you use this algebra, the following operators have to be defined for
            the state_type:
          </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      Name
                    </p>
                  </th>
<th>
                    <p>
                      Expression
                    </p>
                  </th>
<th>
                    <p>
                      Type
                    </p>
                  </th>
<th>
                    <p>
                      Semantics
                    </p>
                  </th>
</tr></thead>
<tbody>
<tr>
<td>
                    <p>
                      Addition
                    </p>
                  </td>
<td>
                    <p>
                      <code class="computeroutput"><span class="identifier">x</span> <span class="special">+</span>
                      <span class="identifier">y</span></code>
                    </p>
                  </td>
<td>
                    <p>
                      <code class="computeroutput"><span class="identifier">state_type</span></code>
                    </p>
                  </td>
<td>
                    <p>
                      Calculates the vector sum 'x+y'.
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      Assign addition
                    </p>
                  </td>
<td>
                    <p>
                      <code class="computeroutput"><span class="identifier">x</span> <span class="special">+=</span>
                      <span class="identifier">y</span></code>
                    </p>
                  </td>
<td>
                    <p>
                      <code class="computeroutput"><span class="identifier">state_type</span></code>
                    </p>
                  </td>
<td>
                    <p>
                      Performs x+y in place.
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      Scalar multiplication
                    </p>
                  </td>
<td>
                    <p>
                      <code class="computeroutput"><span class="identifier">a</span> <span class="special">*</span>
                      <span class="identifier">x</span> </code>
                    </p>
                  </td>
<td>
                    <p>
                      <code class="computeroutput"><span class="identifier">state_type</span></code>
                    </p>
                  </td>
<td>
                    <p>
                      Performs multiplication of vector x with scalar a.
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      Assign scalar multiplication
                    </p>
                  </td>
<td>
                    <p>
                      <code class="computeroutput"><span class="identifier">x</span> <span class="special">*=</span>
                      <span class="identifier">a</span></code>
                    </p>
                  </td>
<td>
                    <p>
                      <code class="computeroutput"><span class="identifier">state_type</span></code>
                    </p>
                  </td>
<td>
                    <p>
                      Performs in-place multiplication of vector x with scalar a.
                    </p>
                  </td>
</tr>
</tbody>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.algebraic_operations.boost_ublas"></a><a class="link" href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.algebraic_operations.boost_ublas" title="Boost.Ublas">Boost.Ublas</a>
</h5></div></div></div>
<p>
            As an example for the employment of the <code class="computeroutput"><span class="identifier">vector_space_algebra</span></code>
            we will adopt <code class="computeroutput"><span class="identifier">ublas</span><span class="special">::</span><span class="identifier">vector</span></code> from <a href="http://www.boost.org/doc/libs/release/libs/numeric/ublas/index.html" target="_top">Boost.UBlas</a>
            to work as a state type in odeint. This is particularily easy because
            <code class="computeroutput"><span class="identifier">ublas</span><span class="special">::</span><span class="identifier">vector</span></code> supports vector-vector addition
            and scalar-vector multiplication described above as well as <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">size</span></code>. It also has a resize member function
            so all that has to be done in this case is to declare resizability:
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">ublas</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">double</span> <span class="special">&gt;</span> <span class="identifier">state_type</span><span class="special">;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">numeric</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">odeint</span> <span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_resizeable</span><span class="special">&lt;</span> <span class="identifier">state_type</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">true_type</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">value</span> <span class="special">=</span> <span class="identifier">type</span><span class="special">::</span><span class="identifier">value</span><span class="special">;</span>
<span class="special">};</span>

<span class="special">}</span> <span class="special">}</span> <span class="special">}</span>
</pre>
<p>
          </p>
<p>
            Now ublas::vector can be used as state type in odeint by specifying the
            <code class="computeroutput"><span class="identifier">vector_space_algebra</span></code>
            as algebra in the template parameter list of the stepper. The following
            code shows the corresponding definitions:
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">state_type</span> <span class="identifier">x</span><span class="special">(</span><span class="number">3</span><span class="special">);</span>
    <span class="identifier">x</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">=</span> <span class="number">10.0</span><span class="special">;</span> <span class="identifier">x</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="number">5.0</span> <span class="special">;</span> <span class="identifier">x</span><span class="special">[</span><span class="number">2</span><span class="special">]</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">runge_kutta4</span><span class="special">&lt;</span> <span class="identifier">state_type</span> <span class="special">,</span> <span class="keyword">double</span> <span class="special">,</span> <span class="identifier">state_type</span> <span class="special">,</span> <span class="keyword">double</span> <span class="special">,</span> <span class="identifier">vector_space_algebra</span> <span class="special">&gt;</span> <span class="identifier">stepper</span><span class="special">;</span>
    <span class="identifier">integrate_const</span><span class="special">(</span> <span class="identifier">stepper</span><span class="special">()</span> <span class="special">,</span> <span class="identifier">lorenz</span> <span class="special">,</span> <span class="identifier">x</span> <span class="special">,</span> 
                     <span class="number">0.0</span> <span class="special">,</span> <span class="number">10.0</span> <span class="special">,</span> <span class="number">0.1</span> <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
            You can find the full example in <a href="https://github.com/headmyshoulder/odeint-v2/tree/master/libs/numeric/odeint/examples/ublas/lorenz_ublas.cpp" target="_top">lorenz_ublas.cpp</a>.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.algebraic_operations.point_type"></a><a class="link" href="adapt_your_own_state_types.html#boost_sandbox_numeric_odeint.extend_odeint.adapt_your_own_state_types.algebraic_operations.point_type" title="Point type">Point
          type</a>
</h5></div></div></div>
<p>
            Here we show how to implement the required operators on a state type.
            As example we define a new class <code class="computeroutput"><span class="identifier">point3D</span></code>
            representing a three-dimensional vector with components x,y,z and define
            addition and scalar multiplication operators for it. We use <a href="http://www.boost.org/doc/libs/release/doc/html/operators.html" target="_top">Boost.Operators</a>
            to reduce the amount of code required. The class for the point type looks
            as follows:
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">point3D</span> <span class="special">:</span>     
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">additive1</span><span class="special">&lt;</span> <span class="identifier">point3D</span> <span class="special">,</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">additive2</span><span class="special">&lt;</span> <span class="identifier">point3D</span> <span class="special">,</span> <span class="keyword">double</span> <span class="special">,</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiplicative2</span><span class="special">&lt;</span> <span class="identifier">point3D</span> <span class="special">,</span> <span class="keyword">double</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>

    <span class="keyword">double</span> <span class="identifier">x</span> <span class="special">,</span> <span class="identifier">y</span> <span class="special">,</span> <span class="identifier">z</span><span class="special">;</span>

    <span class="identifier">point3D</span><span class="special">()</span>
        <span class="special">:</span> <span class="identifier">x</span><span class="special">(</span> <span class="number">0.0</span> <span class="special">)</span> <span class="special">,</span> <span class="identifier">y</span><span class="special">(</span> <span class="number">0.0</span> <span class="special">)</span> <span class="special">,</span> <span class="identifier">z</span><span class="special">(</span> <span class="number">0.0</span> <span class="special">)</span>
    <span class="special">{</span> <span class="special">}</span>
    
    <span class="identifier">point3D</span><span class="special">(</span> <span class="keyword">const</span> <span class="keyword">double</span> <span class="identifier">val</span> <span class="special">)</span>
        <span class="special">:</span> <span class="identifier">x</span><span class="special">(</span> <span class="identifier">val</span> <span class="special">)</span> <span class="special">,</span> <span class="identifier">y</span><span class="special">(</span> <span class="identifier">val</span> <span class="special">)</span> <span class="special">,</span> <span class="identifier">z</span><span class="special">(</span> <span class="identifier">val</span> <span class="special">)</span>
    <span class="special">{</span> <span class="special">}</span>

    <span class="identifier">point3D</span><span class="special">(</span> <span class="keyword">const</span> <span class="keyword">double</span> <span class="identifier">_x</span> <span class="special">,</span> <span class="keyword">const</span> <span class="keyword">double</span> <span class="identifier">_y</span> <span class="special">,</span> <span class="keyword">const</span> <span class="keyword">double</span> <span class="identifier">_z</span>  <span class="special">)</span>
        <span class="special">:</span> <span class="identifier">x</span><span class="special">(</span> <span class="identifier">x</span> <span class="special">)</span> <span class="special">,</span> <span class="identifier">y</span><span class="special">(</span> <span class="identifier">y</span> <span class="special">)</span> <span class="special">,</span> <span class="identifier">z</span><span class="special">(</span> <span class="identifier">z</span> <span class="special">)</span>
    <span class="special">{</span> <span class="special">}</span>

    <span class="identifier">point3D</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">+=(</span> <span class="keyword">const</span> <span class="identifier">point3D</span> <span class="special">&amp;</span><span class="identifier">p</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">x</span> <span class="special">+=</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">x</span><span class="special">;</span> <span class="identifier">y</span> <span class="special">+=</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">y</span><span class="special">;</span> <span class="identifier">z</span> <span class="special">+=</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">z</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="identifier">point3D</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">*=(</span> <span class="keyword">const</span> <span class="keyword">double</span> <span class="identifier">a</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">x</span> <span class="special">*=</span> <span class="identifier">a</span><span class="special">;</span> <span class="identifier">y</span> <span class="special">*=</span> <span class="identifier">a</span><span class="special">;</span> <span class="identifier">z</span> <span class="special">*=</span> <span class="identifier">a</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>
    <span class="special">}</span>

<span class="special">};</span>
</pre>
<p>
          </p>
<p>
            By deriving from <a href="http://www.boost.org/doc/libs/release/doc/html/operators.html" target="_top">Boost.Operators</a>
            classes we don't have to define outer class operators like <code class="computeroutput"><span class="keyword">operator</span><span class="special">+(</span> <span class="identifier">point3D</span> <span class="special">,</span>
            <span class="identifier">point3D</span> <span class="special">)</span></code>
            because that is taken care of by the operators library. Note that for
            simple Runge-Kutta schemes (like <code class="computeroutput"><span class="identifier">runge_kutta4</span></code>)
            only the <code class="computeroutput"><span class="special">+</span></code> and <code class="computeroutput"><span class="special">*</span></code> operators are required. If, however,
            a controlled stepper is used one also needs to specify the division operator
            <code class="computeroutput"><span class="special">/</span></code> because calculation of
            the error term involves an element wise division of the state types.
            Additionally, controlled steppers require an <code class="computeroutput"><span class="identifier">abs</span></code>
            function calculating the element-wise absolute value for the state type:
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="comment">// only required for steppers with error control</span>
<span class="identifier">point3D</span> <span class="keyword">operator</span><span class="special">/(</span> <span class="keyword">const</span> <span class="identifier">point3D</span> <span class="special">&amp;</span><span class="identifier">p1</span> <span class="special">,</span> <span class="keyword">const</span> <span class="identifier">point3D</span> <span class="special">&amp;</span><span class="identifier">p2</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">point3D</span><span class="special">(</span> <span class="identifier">p1</span><span class="special">.</span><span class="identifier">x</span><span class="special">/</span><span class="identifier">p2</span><span class="special">.</span><span class="identifier">x</span> <span class="special">,</span> <span class="identifier">p1</span><span class="special">.</span><span class="identifier">y</span><span class="special">/</span><span class="identifier">p2</span><span class="special">.</span><span class="identifier">y</span> <span class="special">,</span> <span class="identifier">p1</span><span class="special">.</span><span class="identifier">z</span><span class="special">/</span><span class="identifier">p1</span><span class="special">.</span><span class="identifier">z</span> <span class="special">);</span>
<span class="special">}</span>

<span class="identifier">point3D</span> <span class="identifier">abs</span><span class="special">(</span> <span class="keyword">const</span> <span class="identifier">point3D</span> <span class="special">&amp;</span><span class="identifier">p</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">point3D</span><span class="special">(</span> <span class="identifier">abs</span><span class="special">(</span><span class="identifier">p</span><span class="special">.</span><span class="identifier">x</span><span class="special">)</span> <span class="special">,</span> <span class="identifier">abs</span><span class="special">(</span><span class="identifier">p</span><span class="special">.</span><span class="identifier">y</span><span class="special">)</span> <span class="special">,</span> <span class="identifier">abs</span><span class="special">(</span><span class="identifier">p</span><span class="special">.</span><span class="identifier">z</span><span class="special">)</span> <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
            Finally, we have to add a specialization for <code class="computeroutput"><span class="identifier">reduce</span></code>
            implementing a reduction over the state type:
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">numeric</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">odeint</span> <span class="special">{</span>
<span class="comment">// specialization of vector_space_reduce, only required for steppers with error control</span>
<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">vector_space_reduce</span><span class="special">&lt;</span> <span class="identifier">point3D</span> <span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">Value</span> <span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Op</span> <span class="special">&gt;</span>
    <span class="identifier">Value</span> <span class="keyword">operator</span><span class="special">()</span> <span class="special">(</span> <span class="keyword">const</span> <span class="identifier">point3D</span> <span class="special">&amp;</span><span class="identifier">p</span> <span class="special">,</span> <span class="identifier">Op</span> <span class="identifier">op</span> <span class="special">,</span> <span class="identifier">Value</span> <span class="identifier">init</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">init</span> <span class="special">=</span> <span class="identifier">op</span><span class="special">(</span> <span class="identifier">init</span> <span class="special">,</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">x</span> <span class="special">);</span>
        <span class="identifier">init</span> <span class="special">=</span> <span class="identifier">op</span><span class="special">(</span> <span class="identifier">init</span> <span class="special">,</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">y</span> <span class="special">);</span>
        <span class="identifier">init</span> <span class="special">=</span> <span class="identifier">op</span><span class="special">(</span> <span class="identifier">init</span> <span class="special">,</span> <span class="identifier">p</span><span class="special">.</span><span class="identifier">z</span> <span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">init</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
<span class="special">}</span> <span class="special">}</span> <span class="special">}</span> 
</pre>
<p>
          </p>
<p>
            Again, note that the two last steps were only required if you want to
            use controlled steppers. For simple steppers definition of the simple
            <code class="computeroutput"><span class="special">+=</span></code> and <code class="computeroutput"><span class="special">*=</span></code>
            operators are sufficient. Having defined such a point type, we can easily
            perform the integration on a lorenz system by using the <code class="computeroutput"><span class="identifier">vector_space_algebra</span></code> again:
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">const</span> <span class="keyword">double</span> <span class="identifier">sigma</span> <span class="special">=</span> <span class="number">10.0</span><span class="special">;</span>
<span class="keyword">const</span> <span class="keyword">double</span> <span class="identifier">R</span> <span class="special">=</span> <span class="number">28.0</span><span class="special">;</span>
<span class="keyword">const</span> <span class="keyword">double</span> <span class="identifier">b</span> <span class="special">=</span> <span class="number">8.0</span> <span class="special">/</span> <span class="number">3.0</span><span class="special">;</span>

<span class="keyword">void</span> <span class="identifier">lorenz</span><span class="special">(</span> <span class="keyword">const</span> <span class="identifier">point3D</span> <span class="special">&amp;</span><span class="identifier">x</span> <span class="special">,</span> <span class="identifier">point3D</span> <span class="special">&amp;</span><span class="identifier">dxdt</span> <span class="special">,</span> <span class="keyword">const</span> <span class="keyword">double</span> <span class="identifier">t</span> <span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">dxdt</span><span class="special">.</span><span class="identifier">x</span> <span class="special">=</span> <span class="identifier">sigma</span> <span class="special">*</span> <span class="special">(</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">y</span> <span class="special">-</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">x</span> <span class="special">);</span>
    <span class="identifier">dxdt</span><span class="special">.</span><span class="identifier">y</span> <span class="special">=</span> <span class="identifier">R</span> <span class="special">*</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">x</span> <span class="special">-</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">y</span> <span class="special">-</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">x</span> <span class="special">*</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">z</span><span class="special">;</span>
    <span class="identifier">dxdt</span><span class="special">.</span><span class="identifier">z</span> <span class="special">=</span> <span class="special">-</span><span class="identifier">b</span> <span class="special">*</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">z</span> <span class="special">+</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">x</span> <span class="special">*</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">y</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">odeint</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>

    <span class="identifier">point3D</span> <span class="identifier">x</span><span class="special">(</span> <span class="number">10.0</span> <span class="special">,</span> <span class="number">5.0</span> <span class="special">,</span> <span class="number">5.0</span> <span class="special">);</span>
    <span class="comment">//typedef runge_kutta4&lt; point3D , double , point3D , </span>
    <span class="comment">//                      double , vector_space_algebra &gt; stepper;</span>
    <span class="keyword">typedef</span> <span class="identifier">runge_kutta_dopri5</span><span class="special">&lt;</span> <span class="identifier">point3D</span> <span class="special">,</span> <span class="keyword">double</span> <span class="special">,</span> <span class="identifier">point3D</span> <span class="special">,</span> 
                                <span class="keyword">double</span> <span class="special">,</span> <span class="identifier">vector_space_algebra</span> <span class="special">&gt;</span> <span class="identifier">stepper</span><span class="special">;</span>
    <span class="identifier">integrate_adaptive</span><span class="special">(</span> <span class="identifier">make_controlled</span><span class="special">&lt;</span><span class="identifier">stepper</span><span class="special">&gt;(</span> <span class="number">1E-8</span> <span class="special">,</span> <span class="number">1E-8</span> <span class="special">)</span> <span class="special">,</span> <span class="identifier">lorenz</span> <span class="special">,</span> <span class="identifier">x</span> <span class="special">,</span> 
                        <span class="number">0.0</span> <span class="special">,</span> <span class="number">10.0</span> <span class="special">,</span> <span class="number">0.1</span> <span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2009-2011 Karsten Ahnert
      and Mario Mulansky<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../extend_odeint.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../extend_odeint.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="write_own_steppers.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
