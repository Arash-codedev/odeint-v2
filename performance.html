---
layout: default
title: odeint - Performance
---
    
<section>
<h1 id="top">Performance</h1>

<p>
<center>
<img style="margin-left:auto; margin-right:auto;" alt="performance graph" src="img/perf.png" />
</center></p>
<p>
Altough <strong>odeint</strong> is focused on high applicability it still shows
reasonable performance, as you can see in the performance graph above.
There, <strong>odeint</strong> is compared against several other
implementations: <a href="http://www.nr.com/">Numerical Recipes</a>
(nr), <a href="http://www.gnu.org/software/gsl/">GNU Scientific Library</a>
(gsl) and a straight forward Fortran implementation.
All sources can be found in
the <a href="https://github.com/headmyshoulder/odeint-v2/tree/master/libs/numeric/odeint/performance">performance
    directory</a>. 
The performance test is realized by integrating
the <a href="http://en.wikipedia.org/wiki/Lorenz_system">Lorenz system</a> for
20000000 Runge-Kutta4 steps. 
The graph shows the run-time in seconds on a single core of a Intel Core i& 870 (3GHz) using
two different compilers: gcc/gfortran (4.5) and icc/ifort (12.0) using full optimizations
(-O3, -fast).
</p>
<p>
As seen from these results, <strong>odeint</strong> is remarkably fast, beating
the competitors in this test when compiled with gcc-4.5.
We note that even the Fortran version compiled with ifort 12.0, usually
considered as being the fastest choice for numerical simulations, is beaten by
odeint on gcc-4.5.
</p>
<p>
However, these results should be taken with care.
Performance results highly depend on platform, compiler(-version) and the
specific problem.
If you require maximal performance you should measure run-times  for your
specific problem to find the optimal choice of compiler and implementation.
Nevertheless, we believe that <strong>odeint</strong> is a reasonable choice
and has good chances to even provide the best performance.
</p>
</section>
