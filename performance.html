---
layout: default
title: odeint - Performance
---
    
<section>
<h1 id="top">Performance</h1>

<p>
<center>
<img style="margin-left:auto; margin-right:auto;" alt="performance graph" src="img/perf.png" />
</center></p>
<p>
Altough <strong>odeint</strong> is focused on high applicability it still shows
very good performance, as you can see in the performance graph above.
There, <strong>odeint</strong> is compared with a straight forward C implementation as well as a Fortran version.
All sources can be found in
the <a href="https://github.com/headmyshoulder/odeint-v2/tree/master/libs/numeric/odeint/performance">performance directory</a>. 
The performance test is realized by integrating
the <a href="http://en.wikipedia.org/wiki/Lorenz_system">Lorenz system</a> for
20000000 steps using the Runge-Kutta4 scheme. 
The graph shows the run-time in seconds on a single core on three different machines: A Core i5 with 3GHz, a Xeon E5 with 3.8GHz and an Opteron 8431 with 2.4GHz.
For odeint, we show the performance obtained with the gcc-4.9 compiler as well as the intel compiler (v 14.2), both with full optimizations.
</p>
<p>
As seen from these results, <strong>odeint</strong> is certainly competive on both Intel and AMD CPUs and for both the gcc and the Intel compiler.
Despite odeint's high flexibility due to its generic implementation, there are virtually no runtime costs.
If you use odeint you obtain as fast code as using plain C or Fortran code.
</p>
<p>
However, these results should be taken with care.
Performance results highly depend on platform, compiler(-version) and the
specific problem.
If you require maximal performance you should measure run-times  for your
specific problem to find the optimal choice of compiler and implementation.
Nevertheless, we believe that <strong>odeint</strong> is a reasonable choice
and has good chances to even provide the best performance.
</p>
</section>
